## 如何写好一个递归程序？

编写一个清晰、正确且高效的递归程序，首先要明确函数的职责，然后遵循以下核心要素：

0.  **明确递归函数的定义与职责 (Define the Function's Meaning/Specification):**
    *   **是什么？** 在写任何代码之前，先用清晰的语言（比如注释或者在脑海里）**精确地定义这个递归函数是做什么的**。明确它的**输入**是什么，以及对于给定的输入，它应该**返回什么结果**或产生什么**效果**。
    *   **为什么关键？** 这是后续所有步骤的基础。只有明确了 `function(input)` 应该得到什么结果，你才能：
        *   确定最简单情况下的结果（递归出口）。
        *   思考如何将大问题的解依赖于相同函数处理小问题的解（递归调用）。
        *   信任递归调用返回的结果是正确的（因为它遵循你定义的职责）。
    *   **如何做？** 问自己：“我这个函数 `solve(problem_instance)` 究竟要计算或完成什么？”
        *   *例子：*
            *   `factorial(n)` 的定义是：计算非负整数 `n` 的阶乘。
            *   `fib(n)` 的定义是：计算斐波那契数列的第 `n` 项（假设从第 0 项开始）。
            *   `traverse(node)` 的定义是：遍历以 `node` 为根的子树，并执行某种操作（如打印节点值）。
    *   **关键：** 这个定义必须对**所有**合法的输入都成立，包括基本情况和需要递归的情况。递归的威力就在于，你定义好函数的意义后，就可以“假设”它对子问题能正确工作。

1.  **递归出口 (Base Case / Termination Condition):**
    *   **是什么？** 基于你对函数职责的定义，找到问题的**最简单实例**，其结果可以直接确定，无需再次调用自身。
    *   **关键：** 必须存在，且所有递归路径最终能到达。

2.  **递归调用 (Recursive Step / Recursive Call):**
    *   **是什么？** 将当前问题**分解**成一个或多个**规模更小**但**与原问题具有相同结构**（即可以用同一个函数定义来解决）的子问题，并通过**调用自身**来解决这些子问题。
    *   **关键：** 信任递归调用会根据你之前定义的函数职责返回正确的结果。

3.  **确保朝着出口前进 (Making Progress):**
    *   **是什么？** 确保每次递归调用传递的参数都比当前参数**更接近**递归出口。
    *   **关键：** 保证递归过程的收敛性。

4.  **组合子问题的解 (Combining Results):**
    *   **是什么？** 利用递归调用返回的一个或多个子问题的解，来**构造**出当前问题的解，确保结果符合函数的定义。
    *   **关键：** 这是将子问题的解“缝合”起来形成原问题解的步骤。


## 经典问题：$n$皇后问题
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 20;
char ans[N][N];
bool col[N], dg[N], udg[N];  // 其中dg[i], udg[i]的i都是截距
int n;
void dfs(int u) // 第u行
{
	if(u == n)
	{
		for(int i = 0; i < n; i++)
		{
			puts(ans[i]);
		}
		puts("");
		return;
	}
	for(int j = 0; j < n; j++)
	{
		if(!col[j] && !dg[u - j + n] && !udg[u + j])
		{
			ans[u][j] = 'Q';
			col[j] = dg[u - j + n] = udg[u + j] = true;
			dfs(u + 1);
			ans[u][j] = '.'; // 恢复现场
			col[j] = dg[u - j + n] = udg[u + j] = false;			
		}
	}
}

int main()
{
	cin >> n;
	for(int i = 0; i < n; i++)
		for(int j = 0; j < n; j++)
		{
			ans[i][j] = '.';
		}
	dfs(0);
	return 0;
}

```

